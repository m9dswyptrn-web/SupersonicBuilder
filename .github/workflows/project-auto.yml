name: Project Auto

on:
  issues:
    types: [opened, edited, labeled, unlabeled, reopened]
  pull_request:
    types: [opened, edited, labeled, unlabeled, reopened, ready_for_review]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: write
  project: write

jobs:
  add-and-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Load config
        id: cfg
        run: |
          echo "CFG=$(cat .github/project_config.json | tr -d '\n')" >> $GITHUB_OUTPUT

      - name: Add item to project
        uses: actions/add-to-project@v0.5.0
        with:
          project-url: ${{ fromJson(steps.cfg.outputs.CFG).project_url }}
          github-token: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Map labels to project status
        uses: actions/github-script@v7
        env:
          CFG: ${{ steps.cfg.outputs.CFG }}
        with:
          github-token: ${{ secrets.PROJECT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const cfg = JSON.parse(process.env.CFG);
            const statusField = cfg.status_field || "Status";
            const mapping = cfg.label_to_status || {};
            const defStat = cfg.default_status || "Backlog";

            const isPR = !!context.payload.pull_request;
            const item = isPR ? context.payload.pull_request : context.payload.issue;

            // Determine desired status from labels (first match wins)
            const labels = (item.labels || []).map(l => (typeof l === 'string' ? l : l.name).toLowerCase());
            let desired = defStat;
            for (const [label, status] of Object.entries(mapping)) {
              if (labels.includes(label.toLowerCase())) { desired = status; break; }
            }

            // Parse project number
            const projectUrl = cfg.project_url;
            const match = projectUrl.match(/projects\/(\d+)/);
            if (!match) { core.setFailed("Invalid project_url; expected .../projects/<number>"); return; }
            const projectNumber = parseInt(match[1], 10);
            const owner = context.payload.repository.owner.login;
            const org = context.payload.organization?.login || owner;

            const gql = String.raw;
            async function graphql(query, variables) { return await github.graphql(query, variables); }

            // 1) Get project + fields
            const projQ = gql`
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    id
                    fields(first: 50) { nodes { ... on ProjectV2FieldCommon { id name } ... on ProjectV2SingleSelectField { id name options { id name } } } }
                  }
                }
              }`;
            const proj = await graphql(projQ, { org, number: projectNumber });
            const project = proj.organization.projectV2;
            if (!project) { core.setFailed("Project not found"); return; }

            const field = project.fields.nodes.find(f => f.name === statusField);
            if (!field) { core.setFailed(`Field '${statusField}' not found`); return; }
            const opt = (field.options || []).find(o => o.name === desired);
            if (!opt) { core.setFailed(`Status option '${desired}' not found in project`); return; }

            // 3) Find item id in this project; if missing, add it.
            const nodeId = (isPR ? context.payload.pull_request.node_id : context.payload.issue.node_id);
            const nodeQ = gql`
              query($proj: ID!, $item: ID!) {
                node(id: $item) {
                  ... on Issue { id projectItems(first:50) { nodes { id project { id number } } } }
                  ... on PullRequest { id projectItems(first:50) { nodes { id project { id number } } } }
                }
              }`;
            const nodeResp = await graphql(nodeQ, { proj: project.id, item: nodeId });
            const projectItems = nodeResp.node?.projectItems?.nodes || [];
            let itemId = null;
            for (const it of projectItems) {
              if (String(it.project.number) === String(projectNumber)) { itemId = it.id; break; }
            }
            if (!itemId) {
              const addQ = gql`
                mutation($proj: ID!, $content: ID!) {
                  addProjectV2ItemById(input: { projectId: $proj, contentId: $content }) { item { id } }
                }`;
              const addResp = await graphql(addQ, { proj: project.id, content: nodeId });
              itemId = addResp.addProjectV2ItemById.item.id;
            }

            const updQ = gql`
              mutation($proj: ID!, $item: ID!, $field: ID!, $opt: String!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId: $proj,
                  itemId: $item,
                  fieldId: $field,
                  value: { singleSelectOptionId: $opt }
                }) { clientMutationId }
              }`;
            await graphql(updQ, { proj: project.id, item: itemId, field: field.id, opt: opt.id });
            core.info(`Set Status='${desired}' for ${isPR ? "PR" : "Issue"} #${item.number}`);
