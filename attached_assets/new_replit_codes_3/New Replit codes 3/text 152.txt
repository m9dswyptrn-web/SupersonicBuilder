(()=> {
  const $ = (id) => document.getElementById(id);
  const status = (msg) => { const s = $("dp-status"); if (s) s.textContent = msg || ""; };

  // --- selects (assumed existing) ---
  const selMake = $("dp-make"), selModel=$("dp-model"), selYear=$("dp-year"),
        selDiag=$("dp-diagram"), selVar=$("dp-variant"), selFmt=$("dp-format");
  // --- buttons ---
  const btnPrev=$("dp-preview"), btnOpen=$("dp-open"), btnCopy=$("dp-copy"),
        btnRefresh=$("dp-refresh"), btnClose=$("dp-close");
  const btnFirst=$("dp-first"), btnP=$("dp-prev"), btnN=$("dp-next"), btnLast=$("dp-last");
  const btnZoomIn=$("dp-zoomin"), btnZoomOut=$("dp-zoomout"), btnZoomFit=$("dp-zoomfit"),
        btnRotate=$("dp-rotate");
  const btnFitW=$("dp-fitw"), btnFitH=$("dp-fith");
  const btnDlPNG=$("dp-download-png"), btnDlPDF=$("dp-download-pdf"),
        btnZip=$("dp-download-zip"), btnPrint=$("dp-print");
  const btnCancel=$("dp-cancel"), btnRestart=$("dp-restart");
  const pageInfo=$("dp-page-info");

  // --- progress+quality ---
  const sliderQ=$("dp-quality"), sliderVal=$("dp-quality-val");
  const progBar=$("dp-progress-bar"), progText=$("dp-progress-text");

  // --- surfaces ---
  const wrap=$("dp-preview-wrap"), canvas=$("dp-canvas"),
        image=$("dp-image"), spinner=$("dp-spinner");

  // ---- Catalog caching + readiness (env-aware) -----------------------------------
  let catalog = {};
  let catalogReadyResolve; const catalogReady = new Promise(res => (catalogReadyResolve = res));

  const CATALOG_CACHE_KEY = "supersonic-catalog-cache-v1";
  const CATALOG_META_KEY  = "supersonic-catalog-meta-v1";
  let CATALOG_TTL_MS = 6 * 60 * 60 * 1000; // default 6h

  const isLocalHost = () => /^(localhost|127\.0\.0\.1|\[::1\])$/.test(location.hostname);

  const readCache = () => {
    try {
      return {
        data: JSON.parse(localStorage.getItem(CATALOG_CACHE_KEY) || "null"),
        meta: JSON.parse(localStorage.getItem(CATALOG_META_KEY)  || "null"),
      };
    } catch { return { data:null, meta:null }; }
  };
  const writeCache = (data, meta) => {
    try {
      localStorage.setItem(CATALOG_CACHE_KEY, JSON.stringify(data));
      localStorage.setItem(CATALOG_META_KEY,  JSON.stringify(meta));
    } catch {}
  };
  const clearCatalogCache = () => {
    try {
      localStorage.removeItem(CATALOG_CACHE_KEY);
      localStorage.removeItem(CATALOG_META_KEY);
    } catch {}
  };

  function readConfigFromMeta() {
    const m = document.getElementById("catalog-config");
    if (!m) return null;
    const ttlStr = m.getAttribute("data-ttl-ms");
    const verStr = m.getAttribute("data-version");
    const ttl = ttlStr ? parseInt(ttlStr, 10) : null;
    return { ttl_ms: Number.isFinite(ttl) ? ttl : null, version: verStr || null };
  }
  async function fetchCatalogConfig() {
    try {
      const r = await fetch("/api/diagrams/catalog-config", { cache: "no-store" });
      if (!r.ok) return null;
      return await r.json(); // { version, ttl_ms }
    } catch { return null; }
  }
  async function resolveCatalogConfig() {
    const fromMeta = readConfigFromMeta();
    if (fromMeta && (fromMeta.ttl_ms || fromMeta.version)) {
      if (Number.isFinite(fromMeta.ttl_ms)) CATALOG_TTL_MS = fromMeta.ttl_ms;
      return fromMeta;
    }
    const fromNet = await fetchCatalogConfig();
    if (fromNet && Number.isFinite(fromNet.ttl_ms)) {
      CATALOG_TTL_MS = fromNet.ttl_ms;
      return fromNet;
    }
    // final safety net for localhost
    if (isLocalHost()) CATALOG_TTL_MS = 10 * 60 * 1000; // 10m
    return { version: null, ttl_ms: CATALOG_TTL_MS };
  }

  const setCacheNote = (msg) => { const n = $("dp-cache-note"); if (n) n.textContent = msg || ""; };

  const fetchCatalogFresh = async () => {
    const r = await fetch("/api/diagrams/catalog", { cache: "no-store" });
    if (!r.ok) throw new Error("catalog http " + r.status);
    return await r.json();
  };

  async function loadCatalog() {
    status("Loading catalog…");
    const now = Date.now();
    const cfg = await resolveCatalogConfig();
    const serverVersion = cfg?.version || null;
    const { data: cached, meta } = readCache();

    const cacheValidByVersion = !!(cached && meta && serverVersion && meta.version === serverVersion);
    const cacheValidByTTL = !!(cached && meta && (now - (meta.ts || 0) < CATALOG_TTL_MS));

    if (cacheValidByVersion || cacheValidByTTL) {
      catalog = cached;
      status(cacheValidByVersion ? "Catalog ready (matched version)." :
                                   `Catalog ready (TTL ${(CATALOG_TTL_MS/3600000).toFixed(2)}h).`);
      setCacheNote(cacheValidByVersion ? "Source: local cache (version match)" :
                                         "Source: local cache (TTL)");
      try {
        if (serverVersion && (!meta || meta.version !== serverVersion)) {
          const fresh = await fetchCatalogFresh();
          catalog = fresh;
          writeCache(fresh, { version: serverVersion || "unknown", ts: Date.now() });
          status("Catalog updated (background).");
          setCacheNote("Source: refreshed");
        }
      } catch {}
      populateMakeSelect();
      catalogReadyResolve && catalogReadyResolve();
      return;
    }

    try {
      const fresh = await fetchCatalogFresh();
      catalog = fresh;
      writeCache(fresh, { version: serverVersion || "unknown", ts: Date.now() });
      status("Catalog ready.");
      setCacheNote("Source: server");
    } catch (e) {
      if (cached) {
        catalog = cached;
        status("Offline: using cached catalog.");
        setCacheNote("Source: offline cache");
      } else {
        status("Failed to load catalog (no cache).");
        setCacheNote("Source: unavailable");
        catalog = {};
      }
    }
    populateMakeSelect();
    catalogReadyResolve && catalogReadyResolve();
  }

  function populateMakeSelect() {
    if (!selMake) return;
    selMake.innerHTML = `<option value="">— select —</option>`;
    Object.keys(catalog).sort().forEach(mk => {
      const opt = document.createElement("option");
      opt.value = mk; opt.textContent = mk;
      selMake.appendChild(opt);
    });
  }

  // ---- URL/Preview utils --------------------------------------------------------
  function buildURL(withBust=false){
    const mk=encodeURIComponent(selMake.value),
          md=encodeURIComponent(selModel.value),
          yr=encodeURIComponent(selYear.value),
          id=encodeURIComponent(selDiag.value);
    const fmt=encodeURIComponent(selFmt.value),
          variant=encodeURIComponent(selVar.value);
    let url=`/api/diagrams/${mk}/${md}/${yr}/${id}?format=${fmt}&variant=${variant}`;
    if (withBust) url += `&t=${Date.now()}`;
    return url;
  }
  function canAct(){ return !!selDiag?.value; }
  function showSpinner(b){ if(spinner) spinner.hidden=!b; }
  function hidePreview(){ if(!wrap) return; wrap.hidden=true; canvas.hidden=true; image.hidden=true; status(""); setProgress(0,"0%"); }
  function setProgress(pct,label){
    const clamped=Math.max(0,Math.min(100,pct||0));
    if(progBar) progBar.style.width=clamped.toFixed(0)+"%";
    if(progText) progText.textContent = label ? label : clamped.toFixed(0)+"%";
  }
  const getQualityScale = () => {
    const v=parseFloat(sliderQ?.value||"1.25"); return isFinite(v)?v:1.25;
  };
  sliderQ?.addEventListener("input", ()=> { if(sliderVal) sliderVal.textContent = getQualityScale().toFixed(2)+"×"; });
  if (sliderVal) sliderVal.textContent = getQualityScale().toFixed(2)+"×";

  // ---- PDF preview state --------------------------------------------------------
  let pdfDoc=null, pdfURL=null, page=1, pages=0, scale=1.25, rotation=0;
  const ctx = canvas.getContext("2d");
  if (window["pdfjsLib"]) pdfjsLib.GlobalWorkerOptions.workerSrc="/static/vendor/pdfjs/pdf.worker.min.js";

  async function computeFitScale(pdfPage, mode, rotationDeg){
    const surface=canvas.parentElement;
    const sw=surface.clientWidth||900;
    const sh=surface.clientHeight||Math.round(window.innerHeight*.6);
    const v1=pdfPage.getViewport({scale:1, rotation:rotationDeg});
    const fitW = sw / v1.width; const fitH = sh / v1.height;
    return mode==="height" ? fitH : fitW;
  }

  // ---- Cancellation -------------------------------------------------------------
  let CANCEL={active:false}; let pdfLoadingTask=null; let currentRenderTask=null;
  function beginLongTask(){ CANCEL.active=false; if (btnCancel) btnCancel.disabled=false; }
  function endLongTask(){ if (btnCancel) btnCancel.disabled=true; CANCEL.active=false; }
  async function cancelAll(reason="User canceled"){
    CANCEL.active=true; status(reason);
    try { currentRenderTask?.cancel(); } catch {}
    currentRenderTask=null;
    try { await pdfLoadingTask?.destroy?.(); } catch {}
    pdfLoadingTask=null;
    setProgress(0,"0%"); showSpinner(false); hidePreview();
    canvas.width=canvas.height=0; image.src=""; image.hidden=true; canvas.hidden=true; endLongTask();
    showRestart(LAST.has);
  }
  btnCancel?.addEventListener("click", ()=> cancelAll());

  async function loadPDF(url){
    pdfDoc=null; page=1; pages=0; scale=1.25; rotation=0; if(pageInfo) pageInfo.textContent="– / –";
    pdfLoadingTask = pdfjsLib.getDocument(url);
    try {
      const doc = await pdfLoadingTask.promise;
      if (CANCEL.active) throw new Error("cancelled");
      pdfDoc = doc; pages=pdfDoc.numPages; if(pageInfo) pageInfo.textContent = `1 / ${pages}`;
    } catch(e){
      if (String(e).includes("cancel")) throw e;
      console.error(e); status("Failed to load PDF."); throw e;
    } finally { pdfLoadingTask=null; }
  }

  async function renderPage(){
    if(!pdfDoc) return;
    showSpinner(true);
    const pdfPage = await pdfDoc.getPage(page);
    const surfaceWidth = canvas.parentElement.clientWidth || 900;
    const vw = pdfPage.getViewport({scale:1, rotation}).width;
    const fitScale = surfaceWidth / vw;
    const targetScale = Math.max(.1, fitScale * scale);
    const viewport = pdfPage.getViewport({scale:targetScale, rotation});
    canvas.width=viewport.width; canvas.height=viewport.height;
    currentRenderTask = pdfPage.render({ canvasContext: ctx, viewport });
    try {
      await currentRenderTask.promise;
      if (CANCEL.active) throw new Error("cancelled");
      if(pageInfo) pageInfo.textContent=`${page} / ${pages}`;
    }
    catch(e){
      if (!String(e).includes("cancel")) { console.error(e); status("Render failed."); throw e; }
    }
    finally { currentRenderTask=null; showSpinner(false); }
  }

  async function preview(){
    if(!wrap) return;
    wrap.hidden=false; showSpinner(true); beginLongTask();
    const fmt=selFmt.value;
    try {
      if (fmt==="png") {
        pdfDoc=null; image.hidden=false; canvas.hidden=true; image.src=buildURL(true);
        image.onload=()=>{ status(""); showSpinner(false); endLongTask(); rememberState(); };
        image.onerror=()=>{ status("Preview failed."); showSpinner(false); endLongTask(); };
        return;
      }
      image.hidden=true; canvas.hidden=false; pdfURL=buildURL(true);
      await loadPDF(pdfURL); if(CANCEL.active) return;
      await renderPage(); if(CANCEL.active) return;
      rememberState(); status("");
    } catch(_) {
      if(!CANCEL.active) window.open(buildURL(),"_blank","noopener");
    } finally { if(!CANCEL.active) endLongTask(); }
  }

  // --- Controls ---
  btnPrev?.addEventListener("click", preview);
  btnRefresh?.addEventListener("click", ()=> preview());
  btnClose?.addEventListener("click", ()=> hidePreview());
  btnOpen?.addEventListener("click", ()=> window.open(buildURL(),"_blank","noopener"));
  btnCopy?.addEventListener("click", async ()=>{
    const url=location.origin+buildURL();
    try{ await navigator.clipboard.writeText(url); status("URL copied."); setTimeout(()=>status(""),1200); }
    catch{ status("Copy failed. Long-press to copy."); }
  });

  btnFirst?.addEventListener("click", async()=>{ if(!pdfDoc) return; page=1; await renderPage(); rememberState(); });
  btnP?.addEventListener("click", async()=>{ if(!pdfDoc) return; page=Math.max(1,page-1); await renderPage(); rememberState(); });
  btnN?.addEventListener("click", async()=>{ if(!pdfDoc) return; page=Math.min(pages,page+1); await renderPage(); rememberState(); });
  btnLast?.addEventListener("click", async()=>{ if(!pdfDoc) return; page=pages; await renderPage(); rememberState(); });
  btnZoomIn?.addEventListener("click", async()=>{ if(!pdfDoc) return; scale*=1.15; await renderPage(); rememberState(); });
  btnZoomOut?.addEventListener("click", async()=>{ if(!pdfDoc) return; scale/=1.15; await renderPage(); rememberState(); });
  btnZoomFit?.addEventListener("click", async()=>{ if(!pdfDoc) return; scale=1.0; await renderPage(); rememberState(); });
  btnRotate?.addEventListener("click", async()=>{ if(!pdfDoc) return; rotation=(rotation+90)%360; await renderPage(); rememberState(); });
  btnFitW?.addEventListener("click", async()=>{ if(!pdfDoc) return; const p=await pdfDoc.getPage(page); scale=await computeFitScale(p,"width",rotation); await renderPage(); rememberState(); });
  btnFitH?.addEventListener("click", async()=>{ if(!pdfDoc) return; const p=await pdfDoc.getPage(page); scale=await computeFitScale(p,"height",rotation); await renderPage(); rememberState(); });

  // Downloads
  function downloadBlob(blob, filename){
    const url=URL.createObjectURL(blob); const a=document.createElement("a");
    a.href=url; a.download=filename; document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url),5000);
  }

  btnDlPNG?.addEventListener("click", async()=>{
    try {
      if (wrap?.hidden) return;
      if (!image.hidden) {
        const res=await fetch(image.src,{cache:"no-store"}); const blob=await res.blob();
        downloadBlob(blob,`${selMake.value}_${selModel.value}_${selYear.value}_${selDiag.value}.png`);
        return;
      }
      if (canvas.hidden || !pdfDoc) return;
      const q=getQualityScale();
      const off=document.createElement("canvas");
      const w=Math.round(canvas.width*q), h=Math.round(canvas.height*q);
      off.width=w; off.height=h;
      const octx=off.getContext("2d"); octx.imageSmoothingQuality="high";
      octx.drawImage(canvas,0,0,w,h);
      off.toBlob((blob)=>{
        if(!blob) return;
        downloadBlob(blob,`${selMake.value}_${selModel.value}_${selYear.value}_${selDiag.value}_p${page}.png`);
      },"image/png",1.0);
    } catch(e){ console.error(e); status("PNG download failed."); }
  });

  btnDlPDF?.addEventListener("click", async()=>{
    try{
      const url=(pdfDoc&&pdfURL)?pdfURL:buildURL(true).replace("format=png","format=pdf");
      const res=await fetch(url,{cache:"no-store"}); const blob=await res.blob();
      downloadBlob(blob,`${selMake.value}_${selModel.value}_${selYear.value}_${selDiag.value}.pdf`);
    } catch(e){ console.error(e); status("PDF download failed."); }
  });

  btnPrint?.addEventListener("click", async()=>{
    try{
      const url=buildURL().replace("format=png","format=pdf");
      const w = window.open(url,"_blank","noopener");
      if(w){ setTimeout(()=>{ try{ w.focus(); w.print(); }catch{} },600); return; }
    }catch{}
    const srcNode = (!image.hidden)?image:(!canvas.hidden?canvas:null);
    if(!srcNode) return;
    const html = `<html><head><meta charset="utf-8"><title>Print</title>
      <style>body{margin:0;background:#fff;text-align:center} img,canvas{max-width:100%;}</style>
      </head><body>${srcNode.outerHTML||""}</body></html>`;
    const p=window.open("","_blank"); if(!p) return;
    p.document.open(); p.document.write(html); p.document.close(); p.focus();
    setTimeout(()=>{ try{ p.print(); }catch{} },400);
  });

  btnZip?.addEventListener("click", async()=>{
    try {
      beginLongTask(); setProgress(0,"0%");
      const url=buildURL(true).replace("format=png","format=pdf");
      if (!pdfDoc || !pdfURL || pdfURL !== url) {
        wrap.hidden=false; showSpinner(true); pdfURL=url;
        await loadPDF(pdfURL); if(CANCEL.active){ endLongTask(); return; }
      }
      const zip = new JSZip();
      const surface=canvas.parentElement; const sw=surface.clientWidth||900;
      const q=getQualityScale(); const bump=1.5*q; const total=pdfDoc.numPages;

      const tmp=document.createElement("canvas"); const tctx=tmp.getContext("2d",{alpha:false});
      for(let p=1;p<=total;p++){
        if(CANCEL.active){ endLongTask(); return; }
        status(`Rendering page ${p}/${total}…`); setProgress(((p-1)/total)*70);
        const pdfPage=await pdfDoc.getPage(p); if(CANCEL.active){ endLongTask(); return; }
        const v1=pdfPage.getViewport({scale:1, rotation});
        const fitW=(sw/v1.width); const exportScale=fitW*bump;
        const vp=pdfPage.getViewport({scale:exportScale, rotation});
        tmp.width=Math.round(vp.width); tmp.height=Math.round(vp.height);
        currentRenderTask = pdfPage.render({ canvasContext:tctx, viewport:vp });
        try { await currentRenderTask.promise; }
        catch(e){ if(e?.name!=="RenderingCancelledException") throw e; }
        finally { currentRenderTask=null; }
        if(CANCEL.active){ endLongTask(); return; }
        const blob=await new Promise(res=>tmp.toBlob(res,"image/png",1.0));
        const buf=await blob.arrayBuffer();
        const fname=`${selMake.value}_${selModel.value}_${selYear.value}_${selDiag.value}_p${String(p).padStart(2,"0")}.png`;
        zip.file(fname,buf);
      }
      if(CANCEL.active){ endLongTask(); return; }
      status("Zipping…");
      const zipBlob = await zip.generateAsync(
        {type:"blob", compression:"DEFLATE", compressionOptions:{level:9}},
        (meta)=>{ const pct=70+(meta.percent||0)*.30; setProgress(pct,`${Math.round(pct)}%`); }
      );
      const base=`${selMake.value}_${selModel.value}_${selYear.value}_${selDiag.value}`;
      downloadBlob(zipBlob,`${base}_all_pages.zip`);
      setProgress(100,"100%"); status("ZIP ready.");
    } catch(e){ if(!CANCEL.active){ console.error(e); status("ZIP export failed."); } }
    finally { showSpinner(false); if(!CANCEL.active) endLongTask(); }
  });

  // --- Keyboard helpers ---
  document.addEventListener("keydown", async (e)=>{
    if(!canAct()) return;
    if (e.key==="Enter" && !e.shiftKey){ e.preventDefault(); preview(); }
    else if (e.key==="Enter" && e.shiftKey){ e.preventDefault(); window.open(buildURL(),"_blank","noopener"); }
    else if (pdfDoc){
      if(e.key==="ArrowLeft"){ page=Math.max(1,page-1); await renderPage(); rememberState(); }
      if(e.key==="ArrowRight"){ page=Math.min(pages,page+1); await renderPage(); rememberState(); }
      if(e.key==="+"){ scale*=1.15; await renderPage(); rememberState(); }
      if(e.key==="-"){ scale/=1.15; await renderPage(); rememberState(); }
      if(e.key.toLowerCase()==="r"){ rotation=(rotation+90)%360; await renderPage(); rememberState(); }
      if(e.key.toLowerCase()==="f"){ scale=1.0; await renderPage(); rememberState(); }
    }
  });

  // ---- Restart last preview (persisted) -----------------------------------------
  const LAST_KEY = "supersonic-last-preview-v1";
  let LAST = { has:false, fmt:"pdf", url:null, make:"", model:"", year:"", id:"", name:"", variant:"dark", page:1, scale:1.25, rotation:0, ts:null };
  const lblRestart = $("dp-restart-label");

  const loadLastFromStorage = ()=>{ try { return JSON.parse(localStorage.getItem(LAST_KEY)||"{}"); } catch { return {}; } };
  const saveLastToStorage = (p)=>{ try { localStorage.setItem(LAST_KEY, JSON.stringify(p)); } catch {} };
  const clearLastInStorage = ()=>{ try { localStorage.removeItem(LAST_KEY); } catch {} };

  function lastLabelText(){
    if(!LAST||!LAST.has) return "Last: —";
    const base=`${LAST.make} ${LAST.model} ${LAST.year}`.trim();
    const diag=(LAST.name||LAST.id||"—");
    const fmtv=`${(LAST.fmt||"pdf")}, ${(LAST.variant||"dark")}`;
    const pageTxt=(LAST.page&&Number.isFinite(LAST.page))?` · p${LAST.page}`:"";
    return `Last: ${base} · ${diag} (${fmtv})${pageTxt}`;
  }
  function lastTooltipText(){
    if(!LAST||!LAST.has) return "No previous preview.";
    const time=new Date(LAST.ts||Date.now()).toLocaleString();
    const zoom=LAST.scale?`${(LAST.scale*100).toFixed(0)}% zoom`:"";
    const rot=LAST.rotation?`${LAST.rotation}° rotation`:"";
    const fmtv=`${LAST.fmt||"pdf"} · ${LAST.variant||"dark"}`;
    return [
      `${LAST.make} ${LAST.model} ${LAST.year}`,
      `Diagram: ${LAST.name||LAST.id||"—"}`,
      `Format: ${fmtv}`,
      `Page: ${LAST.page||1}`,
      zoom, rot, `Saved: ${time}`
    ].filter(Boolean).join("\n");
  }
  function showRestart(show=true){
    if(btnRestart){
      btnRestart.hidden=!show;
      btnRestart.classList.toggle("fade-visible", !!show);
      btnRestart.title = show?("↺ Restart last preview\n"+lastTooltipText()):"";
    }
    if(lblRestart){
      lblRestart.textContent=lastLabelText();
      lblRestart.hidden=!show;
      lblRestart.classList.toggle("fade-visible", !!show);
      lblRestart.title = show?lastTooltipText():"";
    }
  }
  function rememberState(){
    // guard persistence if user disabled it
    const persist = !!window.SonicSettings?.get()?.persistLast ?? true;

    let friendly = LAST?.id || selDiag.value;
    try {
      const mk=selMake.value, md=selModel.value, yr=selYear.value, id=selDiag.value;
      const item = (catalog?.[mk]?.[md]?.[yr] || []).find(d => d.id === id);
      if (item?.name) friendly = item.name;
    } catch {}

    LAST = {
      has:true, fmt:selFmt.value, url:buildURL(),
      make:selMake.value, model:selModel.value, year:selYear.value, id:selDiag.value,
      name:friendly||selDiag.value, variant:selVar.value,
      page, scale, rotation, ts:Date.now()
    };
    if (persist) saveLastToStorage(LAST);
    showRestart(true);
  }
  function forgetState(){ LAST.has=false; clearLastInStorage(); showRestart(false); }

  [selMake, selModel, selYear, selDiag, selVar, selFmt].forEach(el=> el?.addEventListener("change", ()=> forgetState()));

  btnRestart?.addEventListener("click", async ()=>{
    if(!LAST.has) return;
    await selectVehicle(LAST.make, LAST.model, LAST.year, LAST.id);
    selVar.value = LAST.variant || "dark";
    selFmt.value = LAST.fmt || "pdf";
    wrap.hidden=false; showSpinner(true); beginLongTask();
    try {
      if (LAST.fmt === "png") {
        image.hidden=false; canvas.hidden=true; image.src=LAST.url+"&t="+Date.now();
        image.onload=()=>{ status(""); showSpinner(false); endLongTask(); rememberState(); };
        image.onerror=()=>{ status("Preview failed."); showSpinner(false); endLongTask(); };
        return;
      }
      image.hidden=true; canvas.hidden=false;
      if (!pdfDoc || pdfURL !== LAST.url) { pdfURL=LAST.url; await loadPDF(pdfURL); if(CANCEL.active) return; }
      page=Math.min(Math.max(1, LAST.page||1), pdfDoc.numPages);
      scale=LAST.scale||1.25; rotation=(LAST.rotation||0)%360;
      await renderPage(); if(CANCEL.active) return; rememberState(); status("");
    } catch(e){
      if(!CANCEL.active){ console.error(e); status("Restart failed; opening in new tab."); window.open(LAST.url,"_blank","noopener"); }
    } finally { if(!CANCEL.active) endLongTask(); }
  });

  // Rehydrate from storage on load
  (function initLastFromStorage(){
    const saved=loadLastFromStorage();
    if(saved&&saved.has&&saved.make&&saved.model&&saved.year&&saved.id){
      LAST=saved; showRestart(true);
    } else { forgetState(); }
  })();

  async function selectVehicle(make, model, year, id){
    await catalogReady;
    selMake.value=make; selMake.dispatchEvent(new Event("change")); await Promise.resolve();
    selModel.value=model; selModel.dispatchEvent(new Event("change")); await Promise.resolve();
    selYear.value=year; selYear.dispatchEvent(new Event("change")); await Promise.resolve();
    selDiag.value=id; selDiag.dispatchEvent(new Event("change"));
  }

  // Exports for Settings + external hooks
  window.SonicDiagramPicker = Object.assign({}, window.SonicDiagramPicker, {
    async reloadCatalogNow(){
      clearCatalogCache(); await loadCatalog();
      if(selMake && selMake.value) selMake.dispatchEvent(new Event("change"));
    },
    getTTLms: ()=> CATALOG_TTL_MS,
    restartIfAvailable: async (autoOpen=true)=>{
      const saved=loadLastFromStorage(); if(!saved||!saved.has) return;
      await selectVehicle(saved.make,saved.model,saved.year,saved.id);
      selVar.value=saved.variant||"dark"; selFmt.value=saved.fmt||"pdf";
      LAST=Object.assign({has:true},saved); showRestart(true);
      if (autoOpen){ const r=btnRestart; if(r && !r.hidden) r.click(); }
    }
  });

  // Theme change re-render
  (function(){
    let t=null;
    window.addEventListener("themechange", ()=>{
      if(!pdfDoc||canvas.hidden) return;
      clearTimeout(t);
      t=setTimeout(()=>{ renderPage().catch(()=>{}); },150);
    });
  })();

  // Boot
  loadCatalog();
})();