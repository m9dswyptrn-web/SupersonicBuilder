#!/usr/bin/env python3
"""
Supersonic_Health_Extension.py
Add health + sync endpoints to your app (FastAPI or Flask).

Endpoints:
  GET  /api/ping    → JSON: uptime, git (branch/remote/head/dirty), last sync
  GET  /api/status  → JSON: raw sync state
  GET  /api/ready   → "OK" (200) if healthy or never-run; "ERROR: ..." (503) if last sync failed
  POST /api/sync    → starts a background sync (commit unstaged -> fetch -> ff/rebase/merge -> push)

Usage (FastAPI):
    from Supersonic_Health_Extension import attach
    app = FastAPI()
    attach(app)  # wires routes

Usage (Flask):
    from Supersonic_Health_Extension import attach
    app = Flask(__name__)
    attach(app)  # wires routes

Env (optional):
  GH_TOKEN             -> GitHub PAT (repo scope) if your remote requires credentials
  GIT_AUTHOR_NAME      -> commit identity (default "SonicBuilder Bot")
  GIT_AUTHOR_EMAIL     -> commit identity (default "bot@sonicbuilder.local")
  GITHUB_REPOSITORY    -> owner/repo (informational only)
"""

import os, subprocess, hashlib, threading, time, socket
from datetime import datetime

# -------- Shared state --------
BOOT_TIME = time.time()
STATE = {
    "last_started": None,
    "last_finished": None,
    "last_ok": None,
    "last_msg": "never run",
    "last_commit": None,
}

# -------- Shell helpers --------
def sh(cmd: str, check: bool = True) -> str:
    p = subprocess.run(cmd, shell=True, text=True,
                       stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    if check and p.returncode != 0:
        raise RuntimeError(f"$ {cmd}\n{p.stdout}")
    return p.stdout

def _ensure_git_identity():
    name  = os.getenv("GIT_AUTHOR_NAME",  "SonicBuilder Bot")
    email = os.getenv("GIT_AUTHOR_EMAIL", "bot@sonicbuilder.local")
    sh(f'git config user.name "{name}"')
    sh(f'git config user.email "{email}"')

def _detect_default_branch() -> str:
    # Try origin/HEAD first
    out = sh("git symbolic-ref refs/remotes/origin/HEAD", check=False).strip()
    if out and "/" in out:
        return out.split("/")[-1]
    # Fallbacks
    for b in ("main", "master"):
        if sh(f"git rev-parse --verify {b}", check=False).strip():
            return b
    return "main"

def _commit_any_changes():
    sh("git add -A")
    status = sh("git status --porcelain").strip()
    if status:
        ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
        tree = sh("git write-tree").strip()
        digest = hashlib.sha1(tree.encode()).hexdigest()[:8]
        msg = f"[sync] Replit auto-sync @ {ts} (tree {digest})"
        sh(f'git commit -m "{msg}"')
        STATE["last_commit"] = msg
    else:
        STATE["last_commit"] = "(no local changes)"

def _pull_reconcile_push(branch: str):
    # If your remote needs tokenized URL, configure it outside this script.
    sh("git fetch --prune")
    sh(f"git checkout -B {branch}")
    # 1) Fast-forward if possible
    out = sh(f"git merge --ff-only origin/{branch}", check=False)
    if "fatal:" in out or "not something we can merge" in out:
        # 2) Try rebase
        rebase = sh(f"git rebase origin/{branch}", check=False)
        if "CONFLICT" in rebase:
            # 3) Last resort: abort rebase, do a merge
            sh("git rebase --abort", check=False)
            sh(f"git merge --no-edit origin/{branch}", check=True)
    sh(f"git push --set-upstream origin {branch}")

def _run_sync():
    _ensure_git_identity()
    branch = _detect_default_branch()
    _commit_any_changes()
    _pull_reconcile_push(branch)

def _sync_job():
    try:
        STATE["last_started"]  = datetime.utcnow().isoformat() + "Z"
        _run_sync()
        STATE["last_ok"]  = True
        STATE["last_msg"] = "sync completed"
    except Exception as e:
        STATE["last_ok"]  = False
        STATE["last_msg"] = str(e)
    finally:
        STATE["last_finished"] = datetime.utcnow().isoformat() + "Z"

# -------- FastAPI adapter --------
def _attach_fastapi(app):
    from fastapi import APIRouter
    from pydantic import BaseModel
    from fastapi.responses import PlainTextResponse

    router = APIRouter(prefix="/api", tags=["sync"])

    class SyncQueued(BaseModel):
        queued: bool
        message: str

    @router.post("/sync", response_model=SyncQueued, status_code=202)
    def api_sync_now():
        t = threading.Thread(target=_sync_job, daemon=True)
        t.start()
        return SyncQueued(queued=True, message="Sync started")

    @router.get("/status")
    def api_status():
        return STATE

    @router.get("/ping")
    def api_ping():
        def safe(cmd, default=""):
            try: return sh(cmd, check=False).strip()
            except Exception: return default

        branch = _detect_default_branch()
        remote = safe("git remote get-url origin")
        head   = safe("git rev-parse --short HEAD")
        dirty  = bool(safe("git status --porcelain"))
        last   = safe("git log -1 --pretty=%cI || true")

        if STATE["last_ok"] is True:
            status = "green"; ok = True
        elif STATE["last_ok"] is False:
            status = "red";   ok = False
        else:
            status = "yellow"; ok = True

        return {
            "ok": ok,
            "status": status,
            "ts": datetime.utcnow().isoformat() + "Z",
            "uptime_sec": int(time.time() - BOOT_TIME),
            "host": socket.gethostname(),
            "git": {
                "branch": branch, "remote": remote, "head": head,
                "dirty": dirty, "last_commit_time": last,
            },
            "sync": STATE,
            "env": {
                "repo": os.getenv("GITHUB_REPOSITORY",""),
                "gh_token": "present" if (os.getenv("GH_TOKEN") or os.getenv("GITHUB_TOKEN")) else "missing",
                "port": os.getenv("PORT",""),
                "mode": os.getenv("APP_MODE","prod"),
            }
        }

    @router.get("/ready", response_class=PlainTextResponse)
    def api_ready():
        ok = STATE.get("last_ok")
        if ok is True or STATE["last_msg"] == "never run":
            return PlainTextResponse("OK", status_code=200)
        return PlainTextResponse(f"ERROR: {STATE.get('last_msg','unknown')}", status_code=503)

    app.include_router(router)

# -------- Flask adapter --------
def _attach_flask(app):
    from flask import Blueprint, jsonify
    from flask import Response as FlaskResponse

    bp = Blueprint("sync_bp", __name__, url_prefix="/api")

    @bp.route("/sync", methods=["POST"])
    def api_sync_now():
        t = threading.Thread(target=_sync_job, daemon=True)
        t.start()
        return jsonify({"queued": True, "message": "Sync started"}), 202

    @bp.route("/status", methods=["GET"])
    def api_status():
        return jsonify(STATE), 200

    @bp.route("/ping", methods=["GET"])
    def api_ping():
        def safe(cmd, default=""):
            try: return sh(cmd, check=False).strip()
            except Exception: return default

        branch = _detect_default_branch()
        remote = safe("git remote get-url origin")
        head   = safe("git rev-parse --short HEAD")
        dirty  = bool(safe("git status --porcelain"))
        last   = safe("git log -1 --pretty=%cI || true")

        if STATE["last_ok"] is True:
            status = "green"; ok = True
        elif STATE["last_ok"] is False:
            status = "red";   ok = False
        else:
            status = "yellow"; ok = True

        return jsonify({
            "ok": ok,
            "status": status,
            "ts": datetime.utcnow().isoformat() + "Z",
            "uptime_sec": int(time.time() - BOOT_TIME),
            "host": socket.gethostname(),
            "git": {
                "branch": branch, "remote": remote, "head": head,
                "dirty": dirty, "last_commit_time": last,
            },
            "sync": STATE,
            "env": {
                "repo": os.getenv("GITHUB_REPOSITORY",""),
                "gh_token": "present" if (os.getenv("GH_TOKEN") or os.getenv("GITHUB_TOKEN")) else "missing",
                "port": os.getenv("PORT",""),
                "mode": os.getenv("APP_MODE","prod"),
            }
        }), 200

    @bp.route("/ready", methods=["GET"])
    def api_ready():
        ok = STATE.get("last_ok")
        if ok is True or STATE["last_msg"] == "never run":
            return FlaskResponse("OK", status=200, mimetype="text/plain")
        return FlaskResponse(f"ERROR: {STATE.get('last_msg','unknown')}", status=503, mimetype="text/plain")

    app.register_blueprint(bp)

# -------- Public attach() --------
def attach(app):
    """
    Detects framework and mounts the endpoints.
    - FastAPI: adds /api/ping, /api/ready, /api/status, POST /api/sync
    - Flask:   adds /api/ping, /api/ready, /api/status, POST /api/sync
    """
    mod = type(app).__module__.lower()
    name = type(app).__name__.lower()
    if "fastapi" in mod or "fastapi" in name:
        _attach_fastapi(app)
    elif "flask" in mod or "flask" in name:
        _attach_flask(app)
    else:
        raise RuntimeError("Unsupported app type. Pass a FastAPI or Flask app instance to attach().")