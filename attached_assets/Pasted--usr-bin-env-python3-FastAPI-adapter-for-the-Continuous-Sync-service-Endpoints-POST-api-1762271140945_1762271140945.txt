#!/usr/bin/env python3
# FastAPI adapter for the Continuous Sync service.
# Endpoints:
#   POST /api/sync   -> starts background sync job
#   GET  /api/status -> returns last run status

import os, subprocess, hashlib, threading
from datetime import datetime
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel

router = APIRouter(prefix="/api", tags=["sync"])

STATE = {
    "last_started": None,
    "last_finished": None,
    "last_ok": None,
    "last_msg": "never run",
    "last_commit": None,
}

def sh(cmd: str, check: bool = True) -> str:
    p = subprocess.run(cmd, shell=True, text=True,
                       stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    if check and p.returncode != 0:
        raise RuntimeError(f"$ {cmd}\n{p.stdout}")
    return p.stdout

def _ensure_git_identity():
    name  = os.getenv("GIT_AUTHOR_NAME",  "SonicBuilder Bot")
    email = os.getenv("GIT_AUTHOR_EMAIL", "bot@sonicbuilder.local")
    sh(f'git config user.name "{name}"')
    sh(f'git config user.email "{email}"')

def _detect_default_branch() -> str:
    try:
        out = sh("git symbolic-ref refs/remotes/origin/HEAD", check=False).strip()
        if out and "/" in out:
            return out.split("/")[-1]
    except Exception:
        pass
    return "main"

def _commit_any_changes():
    sh("git add -A")
    status = sh("git status --porcelain").strip()
    if status:
        ts = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
        tree = sh("git write-tree").strip()
        digest = hashlib.sha1(tree.encode()).hexdigest()[:8]
        msg = f"[sync] Replit auto-sync @ {ts} (tree {digest})"
        sh(f'git commit -m "{msg}"')
        STATE["last_commit"] = msg
    else:
        STATE["last_commit"] = "(no local changes)"

def _pull_reconcile_push(branch: str):
    sh("git fetch --prune")
    sh(f"git checkout -B {branch}")
    out = sh(f"git merge --ff-only origin/{branch}", check=False)
    if "fatal:" in out or "not something we can merge" in out:
        rebase = sh(f"git rebase origin/{branch}", check=False)
        if "CONFLICT" in rebase:
            sh("git rebase --abort", check=False)
            sh(f"git merge --no-edit origin/{branch}", check=True)
    sh(f"git push --set-upstream origin {branch}")

def _run_sync():
    _ensure_git_identity()
    branch = _detect_default_branch()
    _commit_any_changes()
    _pull_reconcile_push(branch)

def _sync_job():
    try:
        STATE["last_started"]  = datetime.utcnow().isoformat() + "Z"
        _run_sync()
        STATE["last_ok"]  = True
        STATE["last_msg"] = "sync completed"
    except Exception as e:
        STATE["last_ok"]  = False
        STATE["last_msg"] = str(e)
    finally:
        STATE["last_finished"] = datetime.utcnow().isoformat() + "Z"

class SyncQueued(BaseModel):
    queued: bool
    message: str

@router.post("/sync", response_model=SyncQueued, status_code=202)
def api_sync_now():
    t = threading.Thread(target=_sync_job, daemon=True)
    t.start()
    return SyncQueued(queued=True, message="Sync started")

@router.get("/status")
def api_status():
    return STATE