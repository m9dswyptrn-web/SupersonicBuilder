mkdir -p tools

# --- tools/release_now.sh
cat > tools/release_now.sh <<'BASH'
#!/usr/bin/env bash
set -euo pipefail

# One-shot release tool for SupersonicBuilder
# - Bumps semver (patch/minor/major) or accepts --tag vX.Y.Z
# - Creates an annotated tag
# - Pushes tag using a temporary remote that injects GH_PAT
#
# Usage:
#   tools/release_now.sh --patch
#   tools/release_now.sh --minor
#   tools/release_now.sh --major
#   tools/release_now.sh --tag v2.3.4
# Env:
#   GH_PAT   -> fine-grained or classic token (read/write on repo)
#   BRANCH   -> branch to optionally push with --push-branch (default: main)

BRANCH="${BRANCH:-main}"

die() { echo "‚ùå $*" >&2; exit 1; }

need_clean_tree() {
  if [[ -n "$(git status --porcelain)" ]]; then
    die "Working tree not clean. Commit or stash first."
  fi
}

detect_repo() {
  local url
  url="$(git config --get remote.origin.url || true)"
  url="${url%.git}"
  if [[ "$url" =~ github\.com[:/]+([^/]+)/([^/]+)$ ]]; then
    echo "${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
  else
    echo ""
  fi
}

bump() {
  local major="$1" minor="$2" patch="$3" kind="$4"
  case "$kind" in
    major) echo "$((major+1)).0.0" ;;
    minor) echo "$major.$((minor+1)).0" ;;
    patch) echo "$major.$minor.$((patch+1))" ;;
    *)     echo "$major.$minor.$patch" ;;
  esac
}

# --- parse args
BUMP="patch"
EXPLICIT_TAG=""
PUSH_BRANCH=0

while [[ $# -gt 0 ]]; do
  case "$1" in
    --patch) BUMP="patch"; shift;;
    --minor) BUMP="minor"; shift;;
    --major) BUMP="major"; shift;;
    --tag)   EXPLICIT_TAG="${2:-}"; shift 2;;
    --push-branch) PUSH_BRANCH=1; shift;;
    *) die "Unknown arg: $1";;
  esac
done

need_clean_tree

REPO="$(detect_repo)"
[[ -z "$REPO" ]] && die "Could not detect owner/repo from origin. Set a clean https origin first."

LATEST="$(git describe --tags --abbrev=0 2>/dev/null || echo v0.0.0)"
BASE="${LATEST#v}"
IFS='.' read -r MA MI PA <<<"${BASE:-0.0.0}"

if [[ -n "$EXPLICIT_TAG" ]]; then
  NEXT="${EXPLICIT_TAG#v}"
else
  NEXT="$(bump "$MA" "$MI" "$PA" "$BUMP")"
fi
NEXT_TAG="v${NEXT}"

if git rev-parse "$NEXT_TAG" >/dev/null 2>&1; then
  echo "‚úÖ ${NEXT_TAG} already exists. Nothing to do."
  exit 0
fi

git fetch --tags >/dev/null
git tag -a "$NEXT_TAG" -m "SupersonicBuilder $NEXT_TAG"

CLEAN_URL="https://github.com/${REPO}.git"
TEMP_URL="$CLEAN_URL"
if [[ -n "${GH_PAT:-}" ]]; then
  TEMP_URL="https://x-access-token:${GH_PAT}@github.com/${REPO}.git"
fi

# swap to temp remote, push, then restore
git remote set-url origin "$TEMP_URL"
git push origin "$NEXT_TAG"

if [[ "$PUSH_BRANCH" -eq 1 ]]; then
  git push origin "${BRANCH}:${BRANCH}"
fi

git remote set-url origin "$CLEAN_URL"
echo "üéâ Released ${NEXT_TAG}"
BASH
chmod +x tools/release_now.sh

# --- tools/git_auth.sh
cat > tools/git_auth.sh <<'BASH'
#!/usr/bin/env bash
set -euo pipefail
# Temporarily inject GH_PAT into origin; restore on exit.

CLEAN_URL="$(git config --get remote.origin.url | sed 's#^https\?://x-access-token:[^@]*@#https://#')"
if [[ -z "$CLEAN_URL" ]]; then
  CLEAN_URL="$(git config --get remote.origin.url)"
fi
[[ -z "$CLEAN_URL" ]] && { echo "‚ùå No origin configured"; exit 1; }

if [[ -z "${GH_PAT:-}" ]]; then
  echo "‚ö†Ô∏è  GH_PAT not set; leaving origin as-is."
  exit 0
fi

if [[ "$CLEAN_URL" =~ github\.com ]]; then
  TOKEN_URL="$(echo "$CLEAN_URL" | sed "s#^https\?://#https://x-access-token:${GH_PAT}@#")"
  git remote set-url origin "$TOKEN_URL"
  echo "üîê origin now uses temp token URL"
else
  echo "‚ö†Ô∏è  Origin not GitHub; skipped."
fi
BASH
chmod +x tools/git_auth.sh

# --- tools/verify_github_ready.sh
cat > tools/verify_github_ready.sh <<'BASH'
#!/usr/bin/env bash
set -euo pipefail
[[ -z "${GH_PAT:-}" ]] && { echo "‚ùå GH_PAT missing"; exit 1; }
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "‚ùå Not a git repo"; exit 1; }
git ls-remote >/dev/null 2>&1 || { echo "‚ùå Cannot reach remote"; exit 1; }
echo "‚úÖ Repo + GH_PAT look good"
BASH
chmod +x tools/verify_github_ready.sh