#!/usr/bin/env python3
"""
Continuous repo health + docs sync for SonicBuilderSupersonic.

What it does each cycle:
  1) Runs the full health scan (no changes) to verify status
  2) Rebuilds docs (health report, budgets dashboard if present)
  3) Adds/commits any changed files with a standard message
  4) Pushes to the current branch
  5) Optionally tags a datestamped autosync tag (off by default)

Use:
  python3 tools/continuous_sync.py --once
  python3 tools/continuous_sync.py --watch --interval 600
  python3 tools/continuous_sync.py --dry-run

Env it uses:
  GH_TOKEN               -> GitHub PAT (repo scope)
  GITHUB_REPOSITORY      -> owner/repo (e.g. ChristopherElgin/SonicBuilderSupersonic)
  GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL (optional)
  GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL (optional)
"""
import argparse
import os
import subprocess
import sys
import time
from datetime import datetime

ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))

def run(cmd, check=True, capture=False, env=None):
    print(f"$ {' '.join(cmd)}")
    res = subprocess.run(cmd, cwd=ROOT, check=check,
                         text=True,
                         env=env or os.environ.copy(),
                         stdout=subprocess.PIPE if capture else None,
                         stderr=subprocess.STDOUT if capture else None)
    if capture:
        return res.stdout
    return ""

def git_config_identity():
    # Set safe defaults if not present
    author = os.environ.get("GIT_AUTHOR_NAME") or "SonicBuilder Bot"
    email  = os.environ.get("GIT_AUTHOR_EMAIL") or "sonicbuilder-bot@local"
    run(["git", "config", "user.name", author])
    run(["git", "config", "user.email", email])

def branch_name():
    out = run(["git", "rev-parse", "--abbrev-ref", "HEAD"], capture=True).strip()
    return out or "main"

def changed_files():
    # Returns True if there are staged or unstaged changes
    status = run(["git", "status", "--porcelain"], capture=True)
    return bool(status.strip())

def add_all():
    run(["git", "add", "-A"])

def commit_if_changes(msg):
    if changed_files():
        run(["git", "commit", "-m", msg])
        return True
    print("No changes to commit.")
    return False

def push(branch):
    token = os.environ.get("GH_TOKEN")
    if not token:
        print("WARNING: GH_TOKEN not set; push skipped.")
        return
    # Ensure origin uses token without leaking it to logs
    repo = run(["git", "remote", "get-url", "origin"], capture=True).strip()
    if repo.startswith("https://") and "@github.com" not in repo:
        # transform https://github.com/owner/repo.git -> https://x-access-token:TOKEN@github.com/owner/repo.git
        authed = repo.replace("https://", f"https://x-access-token:{token}@")
        run(["git", "remote", "set-url", "origin", authed])
    run(["git", "push", "origin", branch])

def tag_and_push(tag):
    try:
        run(["git", "tag", "-a", tag, "-m", f"autosync {tag}"])
        run(["git", "push", "origin", tag])
    except subprocess.CalledProcessError as e:
        print(f"Tag push failed (possibly duplicate tag): {e}")

def run_health_scan():
    # Scan only (no auto-organize by default)
    # Makefile targets were added earlier by your health system
    try:
        run(["make", "health-scan"])
    except subprocess.CalledProcessError:
        # fallback to direct script if Makefile missing in this env
        scan = os.path.join(ROOT, "supersonic_full_health_scan.py")
        if os.path.exists(scan):
            run(["python3", scan, "--scan-only"])
        else:
            print("Health scan script not found; continuingâ€¦")

def rebuild_docs():
    # 1) Ensure HEALTH_REPORT.md is up to date
    # 2) If budgets tooling exists, rebuild dashboards
    docs_updater = os.path.join(ROOT, "supersonic_doc_updater.py")
    if os.path.exists(docs_updater):
        run(["python3", docs_updater])

    # Budgets dashboard (optional)
    tools_dir = os.path.join(ROOT, "tools")
    bh = os.path.join(tools_dir, "budgets_history.py")
    bah = os.path.join(tools_dir, "budgets_asset_history.py")
    br = os.path.join(tools_dir, "budgets_report.py")
    env = os.environ.copy()
    if os.path.exists(bh):
        run(["python3", bh], env=env)
    if os.path.exists(bah):
        run(["python3", bah], env=env)
    if os.path.exists(br):
        run(["python3", br], env=env)

def cycle(dry_run=False, add_tag=False):
    git_config_identity()
    br = branch_name()

    # 1) Verify current status
    run_health_scan()

    # 2) Rebuild docs/dashboards
    rebuild_docs()

    # 3) Commit & push if anything changed
    add_all()
    msg = f"chore(sync): auto health + docs sync @ {datetime.utcnow().isoformat(timespec='seconds')}Z"
    if dry_run:
        print("[DRY RUN] Would commit: ", msg)
        return

    made_commit = commit_if_changes(msg)
    if made_commit:
        push(br)
        if add_tag:
            tag = "v" + datetime.utcnow().strftime("%Y.%m.%d-%H%M%S") + "-autosync"
            tag_and_push(tag)

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--once", action="store_true", help="Run a single sync cycle and exit.")
    ap.add_argument("--watch", action="store_true", help="Run forever, sleeping between cycles.")
    ap.add_argument("--interval", type=int, default=600, help="Seconds between sync cycles in watch mode.")
    ap.add_argument("--dry-run", action="store_true", help="Do everything except commit/push.")
    ap.add_argument("--tag", action="store_true", help="Create a datestamped autosync tag when changes are pushed.")
    args = ap.parse_args()

    if not (args.once or args.watch):
        print("Tip: use --once for a single run or --watch for continuous mode.")
    if args.once:
        cycle(dry_run=args.dry_run, add_tag=args.tag)
        return
    if args.watch:
        while True:
            try:
                cycle(dry_run=args.dry_run, add_tag=args.tag)
            except Exception as e:
                print(f"[sync] error: {e}")
            time.sleep(args.interval)

if __name__ == "__main__":
    main()