name: pr-docs-comment
on:
  workflow_run:
    workflows: ["docs-build"]
    types: [completed]

permissions:
  contents: read
  actions: read
  pull-requests: write

jobs:
  comment:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - name: Upsert PR comment with artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const run = context.payload.workflow_run;
            const { owner, repo } = context.repo;

            // Find PR(s) associated with this SHA
            const search = await github.rest.search.issuesAndPullRequests({
              q: `repo:${owner}/${repo} is:pr sha:${run.head_sha}`
            });
            if (!search.data.items.length) {
              core.info('No PR found for this run/sha.');
              return;
            }

            // List artifacts for the run
            const arts = await github.rest.actions.listWorkflowRunArtifacts({
              owner, repo, run_id: run.id
            });
            const rows = arts.data.artifacts.map(a =>
              `| ${a.name} | [download](${a.archive_download_url}) | ${Math.round(a.size_in_bytes/1024/1024)} MB |`
            ).join('\n') || '| (none) |  |  |';

            const MARKER = '<!-- SB_DOCS_ARTIFACTS -->';
            const body = `
${MARKER}
**Docs Build** âœ…

Run: [#${run.run_number}](${run.html_url}) on \`${run.head_branch}\`

| Artifact | Link | Size |
|---|---|---|
${rows}

> Links require GitHub login. Artifacts expire per repo retention settings.
`.trim();

            for (const pr of search.data.items) {
              // Get existing comments on the PR
              const comments = await github.rest.issues.listComments({
                owner, repo, issue_number: pr.number, per_page: 100
              });

              // Find any existing SB marker comments
              const sbComments = comments.data.filter(c =>
                c.body && c.body.includes(MARKER)
              );

              if (sbComments.length) {
                // Update the newest, delete the older ones (cleanup)
                const newest = sbComments.sort((a,b)=> new Date(b.created_at)-new Date(a.created_at))[0];
                if (newest.body !== body) {
                  await github.rest.issues.updateComment({
                    owner, repo, comment_id: newest.id, body
                  });
                }
                // Delete older duplicates
                for (const old of sbComments.filter(c => c.id !== newest.id)) {
                  await github.rest.issues.deleteComment({ owner, repo, comment_id: old.id });
                }
              } else {
                // Create a fresh comment
                await github.rest.issues.createComment({
                  owner, repo, issue_number: pr.number, body
                });
              }
            }
