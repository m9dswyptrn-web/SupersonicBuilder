#!/usr/bin/env python3
"""
Continuous GitHub <-> Replit sync loop.

- Commits & pushes local changes periodically
- Optionally pulls remote changes
- Writes activity logs to .cache/sync_git.log
- Controlled via .cache/sync_enabled flag file
- Safe no-op if nothing changed
"""

import os, time, subprocess, shlex, datetime, pathlib

ROOT = pathlib.Path(__file__).resolve().parents[1]
CACHE = ROOT/".cache"
CACHE.mkdir(exist_ok=True)
FLAG  = CACHE/"sync_enabled"
LOGF  = CACHE/"sync_git.log"

INTERVAL_SEC = int(os.getenv("SYNC_INTERVAL_SEC", "120"))   # 2 min default
PULL_ENABLED = os.getenv("SYNC_PULL", "1") == "1"           # pull remote by default
GIT_USER     = os.getenv("GIT_USER", "ChristopherElgin")
GIT_EMAIL    = os.getenv("GIT_EMAIL", "you@example.com")
REPO_URL     = os.getenv("REPO_URL", "")                    # optional; falls back to git remote

def log(msg:str):
    ts = datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
    with LOGF.open("a", encoding="utf-8") as f:
        f.write(f"[{ts}] {msg}\n")
    print(msg, flush=True)

def run(cmd:str, cwd=ROOT) -> tuple[int,str]:
    p = subprocess.Popen(shlex.split(cmd), cwd=str(cwd),
                         stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    out,_ = p.communicate()
    return p.returncode, out

def ensure_identity():
    run(f'git config user.name "{GIT_USER}"')
    run(f'git config user.email "{GIT_EMAIL}"')

def get_remote():
    if REPO_URL:
        return REPO_URL
    code,out = run("git remote -v")
    if code==0 and "origin" in out:
        return "origin"
    return ""

def changed():
    # staged/unstaged?
    run("git add -A")
    code, out = run("git status --porcelain")
    return out.strip() != ""

def commit_and_push():
    ensure_identity()
    if not changed():
        log("No local changes.")
        return
    msg = datetime.datetime.utcnow().strftime("chore(sync): autosave @ %Y-%m-%d %H:%M:%S UTC")
    run(f'git commit -m "{msg}"')
    remote = get_remote()
    if not remote:
        log("No remote configured; committed locally.")
        return
    code, out = run(f"git push {remote} HEAD:main")
    if code != 0:
        # try default branch if not main
        run(f"git push {remote} HEAD")
    log("Pushed local changes.")

def pull_remote():
    remote = get_remote()
    if not remote:
        return
    code, out = run(f"git fetch {remote}")
    if code==0:
        run("git merge --ff-only FETCH_HEAD")
        log("Pulled remote changes (ff-only).")
    else:
        log("Fetch failed; skipping pull.")

def loop():
    log("Sync loop started.")
    while True:
        if not FLAG.exists():
            time.sleep(2)  # fast poll for enable/disable
            continue
        try:
            if PULL_ENABLED:
                pull_remote()
            commit_and_push()
        except Exception as e:
            log(f"ERROR: {e}")
        time.sleep(INTERVAL_SEC)

if __name__ == "__main__":
    loop()