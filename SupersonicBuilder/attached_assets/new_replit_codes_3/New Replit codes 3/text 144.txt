// ---- Catalog caching + readiness (env-aware) -----------------------------------
let catalog = {};
let catalogReadyResolve;
const catalogReady = new Promise(res => (catalogReadyResolve = res));

const CATALOG_CACHE_KEY = "supersonic-catalog-cache-v1";
const CATALOG_META_KEY  = "supersonic-catalog-meta-v1";

// Default (overridden by meta/endpoint if available)
let CATALOG_TTL_MS = 6 * 60 * 60 * 1000; // 6h

function isLocalHost() {
  return /^(localhost|127\.0\.0\.1|\[::1\])$/.test(location.hostname);
}
function readCache() {
  try {
    return {
      data: JSON.parse(localStorage.getItem(CATALOG_CACHE_KEY) || "null"),
      meta: JSON.parse(localStorage.getItem(CATALOG_META_KEY)  || "null"),
    };
  } catch { return { data:null, meta:null }; }
}
function writeCache(data, meta) {
  try {
    localStorage.setItem(CATALOG_CACHE_KEY, JSON.stringify(data));
    localStorage.setItem(CATALOG_META_KEY,  JSON.stringify(meta));
  } catch {}
}
function clearCatalogCache() {
  try {
    localStorage.removeItem(CATALOG_CACHE_KEY);
    localStorage.removeItem(CATALOG_META_KEY);
  } catch {}
}

function readConfigFromMeta() {
  const m = document.getElementById("catalog-config");
  if (!m) return null;
  const ttlStr = m.getAttribute("data-ttl-ms");
  const verStr = m.getAttribute("data-version");
  const ttl = ttlStr ? parseInt(ttlStr, 10) : null;
  return { ttl_ms: Number.isFinite(ttl) ? ttl : null, version: verStr || null };
}
async function fetchCatalogConfig() {
  try {
    const r = await fetch("/api/diagrams/catalog-config", { cache: "no-store" });
    if (!r.ok) return null;
    return await r.json(); // { version, ttl_ms }
  } catch { return null; }
}
async function resolveCatalogConfig() {
  const fromMeta = readConfigFromMeta();
  if (fromMeta && (fromMeta.ttl_ms || fromMeta.version)) {
    if (Number.isFinite(fromMeta.ttl_ms)) CATALOG_TTL_MS = fromMeta.ttl_ms;
    return fromMeta;
  }
  const fromNet = await fetchCatalogConfig();
  if (fromNet && Number.isFinite(fromNet.ttl_ms)) {
    CATALOG_TTL_MS = fromNet.ttl_ms;
    return fromNet;
  }
  if (isLocalHost()) CATALOG_TTL_MS = 10 * 60 * 1000; // final safety net for localhost: 10m
  return { version: null, ttl_ms: CATALOG_TTL_MS };
}

// Small helper to fill Make select
function populateMakeSelect() {
  const selMake = document.getElementById("dp-make");
  if (!selMake) return;
  selMake.innerHTML = `<option value="">— select —</option>`;
  Object.keys(catalog).sort().forEach(mk => {
    const opt = document.createElement("option");
    opt.value = mk; opt.textContent = mk;
    selMake.appendChild(opt);
  });
}

async function fetchCatalogFresh() {
  const r = await fetch("/api/diagrams/catalog", { cache: "no-store" });
  if (!r.ok) throw new Error("catalog http " + r.status);
  return await r.json();
}

async function loadCatalog() {
  status("Loading catalog…");
  const now = Date.now();
  const cfg = await resolveCatalogConfig();
  const serverVersion = cfg?.version || null;
  const { data: cached, meta } = readCache();

  const cacheValidByVersion = !!(cached && meta && serverVersion && meta.version === serverVersion);
  const cacheValidByTTL = !!(cached && meta && (now - (meta.ts || 0) < CATALOG_TTL_MS));

  if (cacheValidByVersion || cacheValidByTTL) {
    catalog = cached;
    status(cacheValidByVersion ? "Catalog ready (matched version)." : `Catalog ready (TTL ${(CATALOG_TTL_MS/3600000).toFixed(2)}h).`);
    // Background refresh if TTL hit and version changed
    try {
      if (serverVersion && (!meta || meta.version !== serverVersion)) {
        const fresh = await fetchCatalogFresh();
        catalog = fresh;
        writeCache(fresh, { version: serverVersion || "unknown", ts: Date.now() });
        status("Catalog updated (background).");
      }
    } catch {} // ignore background errors
    populateMakeSelect();
    catalogReadyResolve && catalogReadyResolve();
    return;
  }

  try {
    const fresh = await fetchCatalogFresh();
    catalog = fresh;
    writeCache(fresh, { version: serverVersion || "unknown", ts: Date.now() });
    status("Catalog ready.");
  } catch (e) {
    if (cached) {
      catalog = cached;
      status("Offline: using cached catalog.");
    } else {
      status("Failed to load catalog (no cache).");
      catalog = {};
    }
  }
  populateMakeSelect();
  catalogReadyResolve && catalogReadyResolve();
}

// (export hook for Settings → Refresh Catalog button)
window.SonicDiagramPicker = Object.assign({}, window.SonicDiagramPicker, {
  async reloadCatalogNow() {
    clearCatalogCache();
    await loadCatalog();
    const makeSel = document.getElementById("dp-make");
    if (makeSel && makeSel.value) makeSel.dispatchEvent(new Event("change"));
  },
  getTTLms: () => CATALOG_TTL_MS
});